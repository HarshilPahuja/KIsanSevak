-- ============================================
-- AgrI Database Schema for Supabase
-- ============================================
-- This SQL script recreates the database schema for the AgrI application.
-- Run this in your Supabase SQL Editor after creating a new project.

-- ============================================
-- DROP EXISTING TABLES (if any)
-- ============================================
DROP TABLE IF EXISTS crops CASCADE;

-- ============================================
-- CREATE CROPS TABLE
-- ============================================
-- This table stores all crop entries with farmer information, location data,
-- area detection results, investment tracking, and yield predictions.

CREATE TABLE crops (
    -- Primary key and timestamps
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Farmer information
    farmer_name TEXT NOT NULL,
    
    -- Crop details
    crop_type TEXT NOT NULL,
    variety TEXT,
    crop_details TEXT,
    
    -- Location information
    location_name TEXT NOT NULL,
    latitude DOUBLE PRECISION,
    longitude DOUBLE PRECISION,
    
    -- Area measurements
    farm_area_sqm DOUBLE PRECISION,
    detected_area_sqm DOUBLE PRECISION,
    satellite_image_url TEXT,
    
    -- Financial tracking
    investment_amount DOUBLE PRECISION,
    
    -- Planting and harvest dates
    planting_date DATE,
    expected_harvest_date DATE,
    
    -- Yield predictions (generated by AI)
    predicted_yield_kg DOUBLE PRECISION,
    predicted_revenue DOUBLE PRECISION,
    confidence_score DOUBLE PRECISION CHECK (confidence_score >= 0 AND confidence_score <= 1),
    
    -- Status tracking
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'harvested', 'failed')),
    
    -- Additional data stored as JSONB
    weather_data JSONB,
    soil_data JSONB,
    prediction_metadata JSONB,
    
    -- Constraints
    CONSTRAINT crops_farmer_name_not_empty CHECK (char_length(farmer_name) > 0),
    CONSTRAINT crops_crop_type_not_empty CHECK (char_length(crop_type) > 0),
    CONSTRAINT crops_location_name_not_empty CHECK (char_length(location_name) > 0)
);

-- ============================================
-- CREATE INDEXES FOR PERFORMANCE
-- ============================================
-- These indexes optimize common queries in the application

-- Index for fetching crops by farmer name (most common query)
CREATE INDEX idx_crops_farmer_name ON crops(farmer_name);

-- Index for filtering by status
CREATE INDEX idx_crops_status ON crops(status);

-- Index for sorting by creation date (used in most queries)
CREATE INDEX idx_crops_created_at ON crops(created_at DESC);

-- Composite index for farmer + status queries (used in getActiveCrops)
CREATE INDEX idx_crops_farmer_status ON crops(farmer_name, status);

-- Index for location-based queries (if needed in future)
CREATE INDEX idx_crops_location ON crops(latitude, longitude) WHERE latitude IS NOT NULL AND longitude IS NOT NULL;

-- Index for crop type (used in market prices section)
CREATE INDEX idx_crops_crop_type ON crops(crop_type);

-- ============================================
-- CREATE UPDATED_AT TRIGGER
-- ============================================
-- Automatically update the updated_at timestamp when a row is modified

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_crops_updated_at
    BEFORE UPDATE ON crops
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- ENABLE ROW LEVEL SECURITY (RLS)
-- ============================================
-- Enable RLS for security (currently allowing all operations)
-- You can customize these policies based on your authentication requirements

ALTER TABLE crops ENABLE ROW LEVEL SECURITY;

-- Policy: Allow all operations for anonymous users (since VITE_SUPABASE_ANON_KEY is used)
-- NOTE: In production, you should implement proper authentication and restrict access
CREATE POLICY "Allow all operations on crops" ON crops
    FOR ALL
    USING (true)
    WITH CHECK (true);

-- Alternative: If you implement authentication in the future, use policies like:
-- CREATE POLICY "Users can view all crops" ON crops
--     FOR SELECT
--     USING (true);
-- 
-- CREATE POLICY "Users can insert their own crops" ON crops
--     FOR INSERT
--     WITH CHECK (auth.uid()::text = farmer_name OR true);
-- 
-- CREATE POLICY "Users can update their own crops" ON crops
--     FOR UPDATE
--     USING (auth.uid()::text = farmer_name OR true);
-- 
-- CREATE POLICY "Users can delete their own crops" ON crops
--     FOR DELETE
--     USING (auth.uid()::text = farmer_name OR true);

-- ============================================
-- SAMPLE DATA (OPTIONAL)
-- ============================================
-- Uncomment the following to insert sample data for testing

/*
INSERT INTO crops (
    farmer_name,
    crop_type,
    variety,
    crop_details,
    location_name,
    latitude,
    longitude,
    farm_area_sqm,
    investment_amount,
    status
) VALUES
(
    'Test Farmer',
    'Tomato',
    'Hybrid',
    'Growing tomatoes for local market',
    'Maharashtra, India',
    19.0760,
    72.8777,
    5000,
    25000,
    'active'
),
(
    'Test Farmer',
    'Rice',
    'Basmati',
    'Premium rice cultivation',
    'Punjab, India',
    30.7333,
    76.7794,
    10000,
    50000,
    'active'
),
(
    'Test Farmer',
    'Wheat',
    NULL,
    'Standard wheat crop',
    'Uttar Pradesh, India',
    26.8467,
    80.9462,
    8000,
    35000,
    'active'
);
*/

-- ============================================
-- VERIFICATION QUERIES
-- ============================================
-- Run these queries after executing the schema to verify everything is set up correctly

-- Check if table was created successfully
-- SELECT table_name, table_type FROM information_schema.tables WHERE table_name = 'crops';

-- Check all indexes
-- SELECT indexname, indexdef FROM pg_indexes WHERE tablename = 'crops';

-- Check all columns
-- SELECT column_name, data_type, is_nullable, column_default 
-- FROM information_schema.columns 
-- WHERE table_name = 'crops' 
-- ORDER BY ordinal_position;

-- Count rows (should be 0 or 3 if you inserted sample data)
-- SELECT COUNT(*) FROM crops;

-- ============================================
-- NOTES
-- ============================================
-- 1. Market prices are NOT stored in the database. They are stored in code at:
--    src/data/localPrices.ts
--    
-- 2. The application uses these main operations:
--    - createCrop: Insert new crop entries from the form
--    - getActiveCrops: Fetch crops with status='active' for metrics
--    - getCropsByFarmer: Fetch all crops for a specific farmer
--    - updateCropYieldPrediction: Update prediction fields after AI analysis
--    - updateCropStatus: Change status (active -> harvested/failed)
--    - deleteCrop: Remove crop entries
--    - getCropsSummary: Aggregate statistics for dashboard
--
-- 3. After creating the Supabase project:
--    - Copy the VITE_SUPABASE_URL to your .env file
--    - Copy the VITE_SUPABASE_ANON_KEY to your .env file
--    - Run this SQL in the Supabase SQL Editor
--    - Test the connection by running the app
--
-- 4. The crops table is queried by MarketPricesSection.tsx to get crop types
--    and locations, then matches them with local prices from localPrices.ts

-- ============================================
-- END OF SCHEMA
-- ============================================
